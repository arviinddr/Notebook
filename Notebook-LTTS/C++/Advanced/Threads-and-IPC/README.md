# Concurrency(Threads) and IPC
1. [Notes](Notes.md)

## Threads(Functions)
* [Basic Thread Example](exp1a.cpp)
* [Basic Thread with Lambda Function](exp1b.cpp)
* [Basic Thread with for Loop](exp2.cpp)
* [Basic with Delay](exp3.cpp)
* [Simple Data Driven Thread](exp4.cpp)
* [Array of Thread](exp5.cpp)

## Async Threads(Functions)
* [std::async example](exp6a.cpp)
* [parallel sum of array](exp6b.cpp)
* [Basic Promise](exp7a.cpp)
* [Void Promise to just signaling](exp7b.cpp)
* [Array of Promise](exp8.cpp)

## Mutual Execution(Mutex,atomic variable)
* [Race Condition Problem 1](pb1.cpp)
* [Mutex Solution for Pb1](pb1_soln1.cpp)
* [Atom Variable Solution for Pb1](pb1_soln2.cpp)
* [Preventing Loop Overlap using Mutex](pb1_soln3.cpp)
* [Basic Stack Class example](stack.cpp)
* [Stack Class with Mutex](exp9.cpp)
* [lock_guard](exp10a.cpp)
* [unique_lock basic](exp10b.cpp)
* [unique_lock transfer of ownership](exp10c.cpp)
* [Dead Lock Scenario](pb2.cpp)
* [myAtomic class](myAtom.cpp)

## Synchronization(Condition Variable)
* [producer and consumer problem](pb3.cpp)
* [producer and consumer solution](pb3_soln.cpp)
* [Stack class overflow and underflow problem](pb4.cpp)
* [Stack Class(no underflow result)](pb4a_soln.cpp)
* [Stack Class(no overflow result)](pb4b_soln.cpp)

